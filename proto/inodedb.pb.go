// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: inodedb.proto

package proto

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ClusterOperation int32

const (
	ClusterOperation_Join ClusterOperation = 0
	ClusterOperation_Quit ClusterOperation = 2
)

var ClusterOperation_name = map[int32]string{
	0: "Join",
	2: "Quit",
}

var ClusterOperation_value = map[string]int32{
	"Join": 0,
	"Quit": 2,
}

func (x ClusterOperation) String() string {
	return proto.EnumName(ClusterOperation_name, int32(x))
}

func (ClusterOperation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{0}
}

type SpaceType int32

const (
	SpaceType_Inode SpaceType = 0
)

var SpaceType_name = map[int32]string{
	0: "Inode",
}

var SpaceType_value = map[string]int32{
	"Inode": 0,
}

func (x SpaceType) String() string {
	return proto.EnumName(SpaceType_name, int32(x))
}

func (SpaceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{1}
}

type NodeRole int32

const (
	NodeRole_Single      NodeRole = 0
	NodeRole_ShardServer NodeRole = 1
	NodeRole_Master      NodeRole = 2
	NodeRole_Router      NodeRole = 3
)

var NodeRole_name = map[int32]string{
	0: "Single",
	1: "ShardServer",
	2: "Master",
	3: "Router",
}

var NodeRole_value = map[string]int32{
	"Single":      0,
	"ShardServer": 1,
	"Master":      2,
	"Router":      3,
}

func (x NodeRole) String() string {
	return proto.EnumName(NodeRole_name, int32(x))
}

func (NodeRole) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{2}
}

type NodeState int32

const (
	NodeState_Unknown NodeState = 0
	NodeState_Alive   NodeState = 1
	NodeState_Suspect NodeState = 2
	NodeState_Quited  NodeState = 3
)

var NodeState_name = map[int32]string{
	0: "Unknown",
	1: "Alive",
	2: "Suspect",
	3: "Quited",
}

var NodeState_value = map[string]int32{
	"Unknown": 0,
	"Alive":   1,
	"Suspect": 2,
	"Quited":  3,
}

func (x NodeState) String() string {
	return proto.EnumName(NodeState_name, int32(x))
}

func (NodeState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{3}
}

type DiskStatus int32

const (
	DiskStatus_DiskStatusUnknown   DiskStatus = 0
	DiskStatus_DiskStatusNormal    DiskStatus = 1
	DiskStatus_DiskStatusBroken    DiskStatus = 2
	DiskStatus_DiskStatusRepairing DiskStatus = 3
	DiskStatus_DiskStatusRepaired  DiskStatus = 4
)

var DiskStatus_name = map[int32]string{
	0: "DiskStatusUnknown",
	1: "DiskStatusNormal",
	2: "DiskStatusBroken",
	3: "DiskStatusRepairing",
	4: "DiskStatusRepaired",
}

var DiskStatus_value = map[string]int32{
	"DiskStatusUnknown":   0,
	"DiskStatusNormal":    1,
	"DiskStatusBroken":    2,
	"DiskStatusRepairing": 3,
	"DiskStatusRepaired":  4,
}

func (x DiskStatus) String() string {
	return proto.EnumName(DiskStatus_name, int32(x))
}

func (DiskStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{4}
}

type DropStatus int32

const (
	DropStatus_NoDrop   DropStatus = 0
	DropStatus_Dropping DropStatus = 1
	DropStatus_Dropped  DropStatus = 2
)

var DropStatus_name = map[int32]string{
	0: "NoDrop",
	1: "Dropping",
	2: "Dropped",
}

var DropStatus_value = map[string]int32{
	"NoDrop":   0,
	"Dropping": 1,
	"Dropped":  2,
}

func (x DropStatus) String() string {
	return proto.EnumName(DropStatus_name, int32(x))
}

func (DropStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{5}
}

type ShardUpdateType int32

const (
	ShardUpdateType_AddMember    ShardUpdateType = 0
	ShardUpdateType_RemoveMember ShardUpdateType = 1
	ShardUpdateType_SetNormal    ShardUpdateType = 2
)

var ShardUpdateType_name = map[int32]string{
	0: "AddMember",
	1: "RemoveMember",
	2: "SetNormal",
}

var ShardUpdateType_value = map[string]int32{
	"AddMember":    0,
	"RemoveMember": 1,
	"SetNormal":    2,
}

func (x ShardUpdateType) String() string {
	return proto.EnumName(ShardUpdateType_name, int32(x))
}

func (ShardUpdateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{6}
}

type ShardNode_RaftStatus int32

const (
	ShardNode_RaftUnknown ShardNode_RaftStatus = 0
	ShardNode_RaftNormal  ShardNode_RaftStatus = 1
)

var ShardNode_RaftStatus_name = map[int32]string{
	0: "RaftUnknown",
	1: "RaftNormal",
}

var ShardNode_RaftStatus_value = map[string]int32{
	"RaftUnknown": 0,
	"RaftNormal":  1,
}

func (x ShardNode_RaftStatus) String() string {
	return proto.EnumName(ShardNode_RaftStatus_name, int32(x))
}

func (ShardNode_RaftStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{5, 0}
}

type FieldMeta_Type int32

const (
	FieldMeta_Bool      FieldMeta_Type = 0
	FieldMeta_Int       FieldMeta_Type = 1
	FieldMeta_Float     FieldMeta_Type = 2
	FieldMeta_String    FieldMeta_Type = 3
	FieldMeta_Embedding FieldMeta_Type = 4
)

var FieldMeta_Type_name = map[int32]string{
	0: "Bool",
	1: "Int",
	2: "Float",
	3: "String",
	4: "Embedding",
}

var FieldMeta_Type_value = map[string]int32{
	"Bool":      0,
	"Int":       1,
	"Float":     2,
	"String":    3,
	"Embedding": 4,
}

func (x FieldMeta_Type) String() string {
	return proto.EnumName(FieldMeta_Type_name, int32(x))
}

func (FieldMeta_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{8, 0}
}

type FieldMeta_IndexOption int32

const (
	FieldMeta_Null     FieldMeta_IndexOption = 0
	FieldMeta_Indexed  FieldMeta_IndexOption = 1
	FieldMeta_Fulltext FieldMeta_IndexOption = 2
	FieldMeta_Unique   FieldMeta_IndexOption = 3
)

var FieldMeta_IndexOption_name = map[int32]string{
	0: "Null",
	1: "Indexed",
	2: "Fulltext",
	3: "Unique",
}

var FieldMeta_IndexOption_value = map[string]int32{
	"Null":     0,
	"Indexed":  1,
	"Fulltext": 2,
	"Unique":   3,
}

func (x FieldMeta_IndexOption) String() string {
	return proto.EnumName(FieldMeta_IndexOption_name, int32(x))
}

func (FieldMeta_IndexOption) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{8, 1}
}

type CatalogChangeItem_Type int32

const (
	CatalogChangeItem_AddSpace    CatalogChangeItem_Type = 0
	CatalogChangeItem_DeleteSpace CatalogChangeItem_Type = 1
	CatalogChangeItem_AddShard    CatalogChangeItem_Type = 2
)

var CatalogChangeItem_Type_name = map[int32]string{
	0: "AddSpace",
	1: "DeleteSpace",
	2: "AddShard",
}

var CatalogChangeItem_Type_value = map[string]int32{
	"AddSpace":    0,
	"DeleteSpace": 1,
	"AddShard":    2,
}

func (x CatalogChangeItem_Type) String() string {
	return proto.EnumName(CatalogChangeItem_Type_name, int32(x))
}

func (CatalogChangeItem_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{14, 0}
}

type ShardTask_Type int32

const (
	ShardTask_ClearShard ShardTask_Type = 0
	ShardTask_Checkpoint ShardTask_Type = 1
)

var ShardTask_Type_name = map[int32]string{
	0: "ClearShard",
	1: "Checkpoint",
}

var ShardTask_Type_value = map[string]int32{
	"ClearShard": 0,
	"Checkpoint": 1,
}

func (x ShardTask_Type) String() string {
	return proto.EnumName(ShardTask_Type_name, int32(x))
}

func (ShardTask_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{18, 0}
}

type Node struct {
	ID                   NodeID     `protobuf:"varint,1,opt,name=id,proto3,casttype=NodeID" json:"id,omitempty"`
	SetID                SetID      `protobuf:"varint,2,opt,name=set_id,json=setId,proto3,casttype=SetID" json:"set_id,omitempty"`
	State                NodeState  `protobuf:"varint,3,opt,name=state,proto3,enum=inodedb.proto.NodeState" json:"state,omitempty"`
	Addr                 string     `protobuf:"bytes,4,opt,name=addr,proto3" json:"addr,omitempty"`
	GrpcPort             uint32     `protobuf:"varint,6,opt,name=grpc_port,json=grpcPort,proto3" json:"grpc_port,omitempty"`
	HttpPort             uint32     `protobuf:"varint,7,opt,name=http_port,json=httpPort,proto3" json:"http_port,omitempty"`
	RaftPort             uint32     `protobuf:"varint,8,opt,name=raft_port,json=raftPort,proto3" json:"raft_port,omitempty"`
	Az                   string     `protobuf:"bytes,9,opt,name=az,proto3" json:"az,omitempty"`
	Rack                 string     `protobuf:"bytes,10,opt,name=rack,proto3" json:"rack,omitempty"`
	Roles                []NodeRole `protobuf:"varint,11,rep,packed,name=roles,proto3,enum=inodedb.proto.NodeRole" json:"roles,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{0}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetID() NodeID {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Node) GetSetID() SetID {
	if m != nil {
		return m.SetID
	}
	return 0
}

func (m *Node) GetState() NodeState {
	if m != nil {
		return m.State
	}
	return NodeState_Unknown
}

func (m *Node) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *Node) GetGrpcPort() uint32 {
	if m != nil {
		return m.GrpcPort
	}
	return 0
}

func (m *Node) GetHttpPort() uint32 {
	if m != nil {
		return m.HttpPort
	}
	return 0
}

func (m *Node) GetRaftPort() uint32 {
	if m != nil {
		return m.RaftPort
	}
	return 0
}

func (m *Node) GetAz() string {
	if m != nil {
		return m.Az
	}
	return ""
}

func (m *Node) GetRack() string {
	if m != nil {
		return m.Rack
	}
	return ""
}

func (m *Node) GetRoles() []NodeRole {
	if m != nil {
		return m.Roles
	}
	return nil
}

type Disk struct {
	DiskID               DiskID     `protobuf:"varint,1,opt,name=disk_id,json=diskId,proto3,casttype=DiskID" json:"disk_id,omitempty"`
	NodeID               NodeID     `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3,casttype=NodeID" json:"node_id,omitempty"`
	Path                 string     `protobuf:"bytes,4,opt,name=path,proto3" json:"path,omitempty"`
	Status               DiskStatus `protobuf:"varint,5,opt,name=status,proto3,enum=inodedb.proto.DiskStatus" json:"status,omitempty"`
	Readonly             bool       `protobuf:"varint,6,opt,name=readonly,proto3" json:"readonly,omitempty"`
	CreateAt             uint64     `protobuf:"varint,7,opt,name=create_at,json=createAt,proto3" json:"create_at,omitempty"`
	LastUpdate           uint64     `protobuf:"varint,8,opt,name=last_update,json=lastUpdate,proto3" json:"last_update,omitempty"`
	DropStatus           DropStatus `protobuf:"varint,9,opt,name=drop_status,json=dropStatus,proto3,enum=inodedb.proto.DropStatus" json:"drop_status,omitempty"`
	Info                 DiskReport `protobuf:"bytes,10,opt,name=info,proto3" json:"info"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Disk) Reset()         { *m = Disk{} }
func (m *Disk) String() string { return proto.CompactTextString(m) }
func (*Disk) ProtoMessage()    {}
func (*Disk) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{1}
}
func (m *Disk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Disk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Disk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Disk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Disk.Merge(m, src)
}
func (m *Disk) XXX_Size() int {
	return m.Size()
}
func (m *Disk) XXX_DiscardUnknown() {
	xxx_messageInfo_Disk.DiscardUnknown(m)
}

var xxx_messageInfo_Disk proto.InternalMessageInfo

func (m *Disk) GetDiskID() DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *Disk) GetNodeID() NodeID {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *Disk) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Disk) GetStatus() DiskStatus {
	if m != nil {
		return m.Status
	}
	return DiskStatus_DiskStatusUnknown
}

func (m *Disk) GetReadonly() bool {
	if m != nil {
		return m.Readonly
	}
	return false
}

func (m *Disk) GetCreateAt() uint64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *Disk) GetLastUpdate() uint64 {
	if m != nil {
		return m.LastUpdate
	}
	return 0
}

func (m *Disk) GetDropStatus() DropStatus {
	if m != nil {
		return m.DropStatus
	}
	return DropStatus_NoDrop
}

func (m *Disk) GetInfo() DiskReport {
	if m != nil {
		return m.Info
	}
	return DiskReport{}
}

type DiskReport struct {
	DiskID               DiskID   `protobuf:"varint,1,opt,name=disk_id,json=diskId,proto3,casttype=DiskID" json:"disk_id,omitempty"`
	Used                 uint64   `protobuf:"varint,2,opt,name=used,proto3" json:"used,omitempty"`
	Total                uint64   `protobuf:"varint,3,opt,name=total,proto3" json:"total,omitempty"`
	ShardCnt             uint64   `protobuf:"varint,4,opt,name=shardCnt,proto3" json:"shardCnt,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiskReport) Reset()         { *m = DiskReport{} }
func (m *DiskReport) String() string { return proto.CompactTextString(m) }
func (*DiskReport) ProtoMessage()    {}
func (*DiskReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{2}
}
func (m *DiskReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiskReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiskReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiskReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiskReport.Merge(m, src)
}
func (m *DiskReport) XXX_Size() int {
	return m.Size()
}
func (m *DiskReport) XXX_DiscardUnknown() {
	xxx_messageInfo_DiskReport.DiscardUnknown(m)
}

var xxx_messageInfo_DiskReport proto.InternalMessageInfo

func (m *DiskReport) GetDiskID() DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *DiskReport) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *DiskReport) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *DiskReport) GetShardCnt() uint64 {
	if m != nil {
		return m.ShardCnt
	}
	return 0
}

type SpaceMeta struct {
	Sid                  Sid         `protobuf:"varint,1,opt,name=sid,proto3,casttype=Sid" json:"sid,omitempty"`
	Name                 string      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Type                 SpaceType   `protobuf:"varint,3,opt,name=type,proto3,enum=inodedb.proto.SpaceType" json:"type,omitempty"`
	FixedFields          []FieldMeta `protobuf:"bytes,4,rep,name=fixed_fields,json=fixedFields,proto3" json:"fixed_fields"`
	Shards               []Shard     `protobuf:"bytes,5,rep,name=shards,proto3" json:"shards"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SpaceMeta) Reset()         { *m = SpaceMeta{} }
func (m *SpaceMeta) String() string { return proto.CompactTextString(m) }
func (*SpaceMeta) ProtoMessage()    {}
func (*SpaceMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{3}
}
func (m *SpaceMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpaceMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpaceMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpaceMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpaceMeta.Merge(m, src)
}
func (m *SpaceMeta) XXX_Size() int {
	return m.Size()
}
func (m *SpaceMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_SpaceMeta.DiscardUnknown(m)
}

var xxx_messageInfo_SpaceMeta proto.InternalMessageInfo

func (m *SpaceMeta) GetSid() Sid {
	if m != nil {
		return m.Sid
	}
	return 0
}

func (m *SpaceMeta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SpaceMeta) GetType() SpaceType {
	if m != nil {
		return m.Type
	}
	return SpaceType_Inode
}

func (m *SpaceMeta) GetFixedFields() []FieldMeta {
	if m != nil {
		return m.FixedFields
	}
	return nil
}

func (m *SpaceMeta) GetShards() []Shard {
	if m != nil {
		return m.Shards
	}
	return nil
}

type Shard struct {
	ShardID              ShardID     `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3,casttype=ShardID" json:"shard_id,omitempty"`
	Epoch                uint64      `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	InoLimit             uint64      `protobuf:"varint,3,opt,name=ino_limit,json=inoLimit,proto3" json:"ino_limit,omitempty"`
	InoUsed              uint64      `protobuf:"varint,4,opt,name=ino_used,json=inoUsed,proto3" json:"ino_used,omitempty"`
	LeaderID             DiskID      `protobuf:"varint,5,opt,name=leader_id,json=leaderId,proto3,casttype=DiskID" json:"leader_id,omitempty"`
	Nodes                []ShardNode `protobuf:"bytes,6,rep,name=nodes,proto3" json:"nodes"`
	InoCursor            uint64      `protobuf:"varint,7,opt,name=ino_cursor,json=inoCursor,proto3" json:"ino_cursor,omitempty"`
	LinkCount            uint64      `protobuf:"varint,8,opt,name=link_count,json=linkCount,proto3" json:"link_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Shard) Reset()         { *m = Shard{} }
func (m *Shard) String() string { return proto.CompactTextString(m) }
func (*Shard) ProtoMessage()    {}
func (*Shard) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{4}
}
func (m *Shard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Shard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Shard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Shard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Shard.Merge(m, src)
}
func (m *Shard) XXX_Size() int {
	return m.Size()
}
func (m *Shard) XXX_DiscardUnknown() {
	xxx_messageInfo_Shard.DiscardUnknown(m)
}

var xxx_messageInfo_Shard proto.InternalMessageInfo

func (m *Shard) GetShardID() ShardID {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *Shard) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *Shard) GetInoLimit() uint64 {
	if m != nil {
		return m.InoLimit
	}
	return 0
}

func (m *Shard) GetInoUsed() uint64 {
	if m != nil {
		return m.InoUsed
	}
	return 0
}

func (m *Shard) GetLeaderID() DiskID {
	if m != nil {
		return m.LeaderID
	}
	return 0
}

func (m *Shard) GetNodes() []ShardNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *Shard) GetInoCursor() uint64 {
	if m != nil {
		return m.InoCursor
	}
	return 0
}

func (m *Shard) GetLinkCount() uint64 {
	if m != nil {
		return m.LinkCount
	}
	return 0
}

type ShardNode struct {
	DiskID               DiskID               `protobuf:"varint,1,opt,name=disk_id,json=diskId,proto3,casttype=DiskID" json:"disk_id,omitempty"`
	Learner              bool                 `protobuf:"varint,2,opt,name=learner,proto3" json:"learner,omitempty"`
	Status               ShardNode_RaftStatus `protobuf:"varint,3,opt,name=status,proto3,enum=inodedb.proto.ShardNode_RaftStatus" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ShardNode) Reset()         { *m = ShardNode{} }
func (m *ShardNode) String() string { return proto.CompactTextString(m) }
func (*ShardNode) ProtoMessage()    {}
func (*ShardNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{5}
}
func (m *ShardNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardNode.Merge(m, src)
}
func (m *ShardNode) XXX_Size() int {
	return m.Size()
}
func (m *ShardNode) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardNode.DiscardUnknown(m)
}

var xxx_messageInfo_ShardNode proto.InternalMessageInfo

func (m *ShardNode) GetDiskID() DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *ShardNode) GetLearner() bool {
	if m != nil {
		return m.Learner
	}
	return false
}

func (m *ShardNode) GetStatus() ShardNode_RaftStatus {
	if m != nil {
		return m.Status
	}
	return ShardNode_RaftUnknown
}

type Item struct {
	Ino                  uint64   `protobuf:"varint,1,opt,name=ino,proto3" json:"ino,omitempty"`
	Links                uint64   `protobuf:"varint,2,opt,name=links,proto3" json:"links,omitempty"`
	Fields               []Field  `protobuf:"bytes,3,rep,name=fields,proto3" json:"fields"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Item) Reset()         { *m = Item{} }
func (m *Item) String() string { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()    {}
func (*Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{6}
}
func (m *Item) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Item.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Item.Merge(m, src)
}
func (m *Item) XXX_Size() int {
	return m.Size()
}
func (m *Item) XXX_DiscardUnknown() {
	xxx_messageInfo_Item.DiscardUnknown(m)
}

var xxx_messageInfo_Item proto.InternalMessageInfo

func (m *Item) GetIno() uint64 {
	if m != nil {
		return m.Ino
	}
	return 0
}

func (m *Item) GetLinks() uint64 {
	if m != nil {
		return m.Links
	}
	return 0
}

func (m *Item) GetFields() []Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

type Field struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value                []byte   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Field) Reset()         { *m = Field{} }
func (m *Field) String() string { return proto.CompactTextString(m) }
func (*Field) ProtoMessage()    {}
func (*Field) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{7}
}
func (m *Field) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Field) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Field.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Field) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Field.Merge(m, src)
}
func (m *Field) XXX_Size() int {
	return m.Size()
}
func (m *Field) XXX_DiscardUnknown() {
	xxx_messageInfo_Field.DiscardUnknown(m)
}

var xxx_messageInfo_Field proto.InternalMessageInfo

func (m *Field) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Field) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type FieldMeta struct {
	Name                 string                `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type                 FieldMeta_Type        `protobuf:"varint,2,opt,name=type,proto3,enum=inodedb.proto.FieldMeta_Type" json:"type,omitempty"`
	Indexed              FieldMeta_IndexOption `protobuf:"varint,3,opt,name=indexed,proto3,enum=inodedb.proto.FieldMeta_IndexOption" json:"indexed,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *FieldMeta) Reset()         { *m = FieldMeta{} }
func (m *FieldMeta) String() string { return proto.CompactTextString(m) }
func (*FieldMeta) ProtoMessage()    {}
func (*FieldMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{8}
}
func (m *FieldMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FieldMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FieldMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldMeta.Merge(m, src)
}
func (m *FieldMeta) XXX_Size() int {
	return m.Size()
}
func (m *FieldMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldMeta.DiscardUnknown(m)
}

var xxx_messageInfo_FieldMeta proto.InternalMessageInfo

func (m *FieldMeta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FieldMeta) GetType() FieldMeta_Type {
	if m != nil {
		return m.Type
	}
	return FieldMeta_Bool
}

func (m *FieldMeta) GetIndexed() FieldMeta_IndexOption {
	if m != nil {
		return m.Indexed
	}
	return FieldMeta_Null
}

type Embedding struct {
	Elements             []float32 `protobuf:"fixed32,1,rep,packed,name=elements,proto3" json:"elements,omitempty"`
	Source               string    `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Embedding) Reset()         { *m = Embedding{} }
func (m *Embedding) String() string { return proto.CompactTextString(m) }
func (*Embedding) ProtoMessage()    {}
func (*Embedding) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{9}
}
func (m *Embedding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Embedding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Embedding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Embedding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Embedding.Merge(m, src)
}
func (m *Embedding) XXX_Size() int {
	return m.Size()
}
func (m *Embedding) XXX_DiscardUnknown() {
	xxx_messageInfo_Embedding.DiscardUnknown(m)
}

var xxx_messageInfo_Embedding proto.InternalMessageInfo

func (m *Embedding) GetElements() []float32 {
	if m != nil {
		return m.Elements
	}
	return nil
}

func (m *Embedding) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

type Link struct {
	Parent               uint64   `protobuf:"varint,1,opt,name=parent,proto3" json:"parent,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Child                uint64   `protobuf:"varint,3,opt,name=child,proto3" json:"child,omitempty"`
	Fields               []Field  `protobuf:"bytes,4,rep,name=fields,proto3" json:"fields"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Link) Reset()         { *m = Link{} }
func (m *Link) String() string { return proto.CompactTextString(m) }
func (*Link) ProtoMessage()    {}
func (*Link) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{10}
}
func (m *Link) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Link) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Link.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Link) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link.Merge(m, src)
}
func (m *Link) XXX_Size() int {
	return m.Size()
}
func (m *Link) XXX_DiscardUnknown() {
	xxx_messageInfo_Link.DiscardUnknown(m)
}

var xxx_messageInfo_Link proto.InternalMessageInfo

func (m *Link) GetParent() uint64 {
	if m != nil {
		return m.Parent
	}
	return 0
}

func (m *Link) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Link) GetChild() uint64 {
	if m != nil {
		return m.Child
	}
	return 0
}

func (m *Link) GetFields() []Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

type GetLink struct {
	Parent               uint64   `protobuf:"varint,1,opt,name=parent,proto3" json:"parent,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetLink) Reset()         { *m = GetLink{} }
func (m *GetLink) String() string { return proto.CompactTextString(m) }
func (*GetLink) ProtoMessage()    {}
func (*GetLink) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{11}
}
func (m *GetLink) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLink.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLink.Merge(m, src)
}
func (m *GetLink) XXX_Size() int {
	return m.Size()
}
func (m *GetLink) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLink.DiscardUnknown(m)
}

var xxx_messageInfo_GetLink proto.InternalMessageInfo

func (m *GetLink) GetParent() uint64 {
	if m != nil {
		return m.Parent
	}
	return 0
}

func (m *GetLink) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Unlink struct {
	Parent               uint64   `protobuf:"varint,1,opt,name=parent,proto3" json:"parent,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Unlink) Reset()         { *m = Unlink{} }
func (m *Unlink) String() string { return proto.CompactTextString(m) }
func (*Unlink) ProtoMessage()    {}
func (*Unlink) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{12}
}
func (m *Unlink) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Unlink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Unlink.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Unlink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Unlink.Merge(m, src)
}
func (m *Unlink) XXX_Size() int {
	return m.Size()
}
func (m *Unlink) XXX_DiscardUnknown() {
	xxx_messageInfo_Unlink.DiscardUnknown(m)
}

var xxx_messageInfo_Unlink proto.InternalMessageInfo

func (m *Unlink) GetParent() uint64 {
	if m != nil {
		return m.Parent
	}
	return 0
}

func (m *Unlink) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ShardReport struct {
	Sid                  Sid      `protobuf:"varint,1,opt,name=sid,proto3,casttype=Sid" json:"sid,omitempty"`
	DiskID               DiskID   `protobuf:"varint,2,opt,name=disk_id,json=diskId,proto3,casttype=DiskID" json:"disk_id,omitempty"`
	Shard                Shard    `protobuf:"bytes,3,opt,name=shard,proto3" json:"shard"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShardReport) Reset()         { *m = ShardReport{} }
func (m *ShardReport) String() string { return proto.CompactTextString(m) }
func (*ShardReport) ProtoMessage()    {}
func (*ShardReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{13}
}
func (m *ShardReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardReport.Merge(m, src)
}
func (m *ShardReport) XXX_Size() int {
	return m.Size()
}
func (m *ShardReport) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardReport.DiscardUnknown(m)
}

var xxx_messageInfo_ShardReport proto.InternalMessageInfo

func (m *ShardReport) GetSid() Sid {
	if m != nil {
		return m.Sid
	}
	return 0
}

func (m *ShardReport) GetDiskID() DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *ShardReport) GetShard() Shard {
	if m != nil {
		return m.Shard
	}
	return Shard{}
}

type CatalogChangeItem struct {
	RouteVersion         RouteVersion           `protobuf:"varint,1,opt,name=route_version,json=routeVersion,proto3,casttype=RouteVersion" json:"route_version,omitempty"`
	Type                 CatalogChangeItem_Type `protobuf:"varint,2,opt,name=type,proto3,enum=inodedb.proto.CatalogChangeItem_Type" json:"type,omitempty"`
	Item                 *types.Any             `protobuf:"bytes,3,opt,name=item,proto3" json:"item,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *CatalogChangeItem) Reset()         { *m = CatalogChangeItem{} }
func (m *CatalogChangeItem) String() string { return proto.CompactTextString(m) }
func (*CatalogChangeItem) ProtoMessage()    {}
func (*CatalogChangeItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{14}
}
func (m *CatalogChangeItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CatalogChangeItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CatalogChangeItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CatalogChangeItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogChangeItem.Merge(m, src)
}
func (m *CatalogChangeItem) XXX_Size() int {
	return m.Size()
}
func (m *CatalogChangeItem) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogChangeItem.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogChangeItem proto.InternalMessageInfo

func (m *CatalogChangeItem) GetRouteVersion() RouteVersion {
	if m != nil {
		return m.RouteVersion
	}
	return 0
}

func (m *CatalogChangeItem) GetType() CatalogChangeItem_Type {
	if m != nil {
		return m.Type
	}
	return CatalogChangeItem_AddSpace
}

func (m *CatalogChangeItem) GetItem() *types.Any {
	if m != nil {
		return m.Item
	}
	return nil
}

type CatalogChangeSpaceAdd struct {
	Sid                  Sid         `protobuf:"varint,1,opt,name=sid,proto3,casttype=Sid" json:"sid,omitempty"`
	Name                 string      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Type                 SpaceType   `protobuf:"varint,3,opt,name=type,proto3,enum=inodedb.proto.SpaceType" json:"type,omitempty"`
	FixedFields          []FieldMeta `protobuf:"bytes,4,rep,name=fixed_fields,json=fixedFields,proto3" json:"fixed_fields"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *CatalogChangeSpaceAdd) Reset()         { *m = CatalogChangeSpaceAdd{} }
func (m *CatalogChangeSpaceAdd) String() string { return proto.CompactTextString(m) }
func (*CatalogChangeSpaceAdd) ProtoMessage()    {}
func (*CatalogChangeSpaceAdd) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{15}
}
func (m *CatalogChangeSpaceAdd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CatalogChangeSpaceAdd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CatalogChangeSpaceAdd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CatalogChangeSpaceAdd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogChangeSpaceAdd.Merge(m, src)
}
func (m *CatalogChangeSpaceAdd) XXX_Size() int {
	return m.Size()
}
func (m *CatalogChangeSpaceAdd) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogChangeSpaceAdd.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogChangeSpaceAdd proto.InternalMessageInfo

func (m *CatalogChangeSpaceAdd) GetSid() Sid {
	if m != nil {
		return m.Sid
	}
	return 0
}

func (m *CatalogChangeSpaceAdd) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CatalogChangeSpaceAdd) GetType() SpaceType {
	if m != nil {
		return m.Type
	}
	return SpaceType_Inode
}

func (m *CatalogChangeSpaceAdd) GetFixedFields() []FieldMeta {
	if m != nil {
		return m.FixedFields
	}
	return nil
}

type CatalogChangeSpaceDelete struct {
	Sid                  Sid      `protobuf:"varint,1,opt,name=sid,proto3,casttype=Sid" json:"sid,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogChangeSpaceDelete) Reset()         { *m = CatalogChangeSpaceDelete{} }
func (m *CatalogChangeSpaceDelete) String() string { return proto.CompactTextString(m) }
func (*CatalogChangeSpaceDelete) ProtoMessage()    {}
func (*CatalogChangeSpaceDelete) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{16}
}
func (m *CatalogChangeSpaceDelete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CatalogChangeSpaceDelete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CatalogChangeSpaceDelete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CatalogChangeSpaceDelete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogChangeSpaceDelete.Merge(m, src)
}
func (m *CatalogChangeSpaceDelete) XXX_Size() int {
	return m.Size()
}
func (m *CatalogChangeSpaceDelete) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogChangeSpaceDelete.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogChangeSpaceDelete proto.InternalMessageInfo

func (m *CatalogChangeSpaceDelete) GetSid() Sid {
	if m != nil {
		return m.Sid
	}
	return 0
}

func (m *CatalogChangeSpaceDelete) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type CatalogChangeShardAdd struct {
	Sid                  Sid         `protobuf:"varint,1,opt,name=sid,proto3,casttype=Sid" json:"sid,omitempty"`
	Name                 string      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	ShardID              ShardID     `protobuf:"varint,3,opt,name=shard_id,json=shardId,proto3,casttype=ShardID" json:"shard_id,omitempty"`
	Epoch                uint64      `protobuf:"varint,4,opt,name=epoch,proto3" json:"epoch,omitempty"`
	InoLimit             uint64      `protobuf:"varint,5,opt,name=ino_limit,json=inoLimit,proto3" json:"ino_limit,omitempty"`
	Leader               DiskID      `protobuf:"varint,6,opt,name=leader,proto3,casttype=DiskID" json:"leader,omitempty"`
	Nodes                []ShardNode `protobuf:"bytes,7,rep,name=nodes,proto3" json:"nodes"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *CatalogChangeShardAdd) Reset()         { *m = CatalogChangeShardAdd{} }
func (m *CatalogChangeShardAdd) String() string { return proto.CompactTextString(m) }
func (*CatalogChangeShardAdd) ProtoMessage()    {}
func (*CatalogChangeShardAdd) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{17}
}
func (m *CatalogChangeShardAdd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CatalogChangeShardAdd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CatalogChangeShardAdd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CatalogChangeShardAdd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogChangeShardAdd.Merge(m, src)
}
func (m *CatalogChangeShardAdd) XXX_Size() int {
	return m.Size()
}
func (m *CatalogChangeShardAdd) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogChangeShardAdd.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogChangeShardAdd proto.InternalMessageInfo

func (m *CatalogChangeShardAdd) GetSid() Sid {
	if m != nil {
		return m.Sid
	}
	return 0
}

func (m *CatalogChangeShardAdd) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CatalogChangeShardAdd) GetShardID() ShardID {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *CatalogChangeShardAdd) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *CatalogChangeShardAdd) GetInoLimit() uint64 {
	if m != nil {
		return m.InoLimit
	}
	return 0
}

func (m *CatalogChangeShardAdd) GetLeader() DiskID {
	if m != nil {
		return m.Leader
	}
	return 0
}

func (m *CatalogChangeShardAdd) GetNodes() []ShardNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type ShardTask struct {
	Type                 ShardTask_Type `protobuf:"varint,1,opt,name=type,proto3,enum=inodedb.proto.ShardTask_Type" json:"type,omitempty"`
	DiskID               DiskID         `protobuf:"varint,2,opt,name=disk_id,json=diskId,proto3,casttype=DiskID" json:"disk_id,omitempty"`
	Sid                  Sid            `protobuf:"varint,3,opt,name=sid,proto3,casttype=Sid" json:"sid,omitempty"`
	ShardID              ShardID        `protobuf:"varint,4,opt,name=shard_id,json=shardId,proto3,casttype=ShardID" json:"shard_id,omitempty"`
	Epoch                uint64         `protobuf:"varint,5,opt,name=epoch,proto3" json:"epoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ShardTask) Reset()         { *m = ShardTask{} }
func (m *ShardTask) String() string { return proto.CompactTextString(m) }
func (*ShardTask) ProtoMessage()    {}
func (*ShardTask) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e11cd2a3cf7b325, []int{18}
}
func (m *ShardTask) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardTask) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardTask.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardTask) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardTask.Merge(m, src)
}
func (m *ShardTask) XXX_Size() int {
	return m.Size()
}
func (m *ShardTask) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardTask.DiscardUnknown(m)
}

var xxx_messageInfo_ShardTask proto.InternalMessageInfo

func (m *ShardTask) GetType() ShardTask_Type {
	if m != nil {
		return m.Type
	}
	return ShardTask_ClearShard
}

func (m *ShardTask) GetDiskID() DiskID {
	if m != nil {
		return m.DiskID
	}
	return 0
}

func (m *ShardTask) GetSid() Sid {
	if m != nil {
		return m.Sid
	}
	return 0
}

func (m *ShardTask) GetShardID() ShardID {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *ShardTask) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func init() {
	proto.RegisterEnum("inodedb.proto.ClusterOperation", ClusterOperation_name, ClusterOperation_value)
	proto.RegisterEnum("inodedb.proto.SpaceType", SpaceType_name, SpaceType_value)
	proto.RegisterEnum("inodedb.proto.NodeRole", NodeRole_name, NodeRole_value)
	proto.RegisterEnum("inodedb.proto.NodeState", NodeState_name, NodeState_value)
	proto.RegisterEnum("inodedb.proto.DiskStatus", DiskStatus_name, DiskStatus_value)
	proto.RegisterEnum("inodedb.proto.DropStatus", DropStatus_name, DropStatus_value)
	proto.RegisterEnum("inodedb.proto.ShardUpdateType", ShardUpdateType_name, ShardUpdateType_value)
	proto.RegisterEnum("inodedb.proto.ShardNode_RaftStatus", ShardNode_RaftStatus_name, ShardNode_RaftStatus_value)
	proto.RegisterEnum("inodedb.proto.FieldMeta_Type", FieldMeta_Type_name, FieldMeta_Type_value)
	proto.RegisterEnum("inodedb.proto.FieldMeta_IndexOption", FieldMeta_IndexOption_name, FieldMeta_IndexOption_value)
	proto.RegisterEnum("inodedb.proto.CatalogChangeItem_Type", CatalogChangeItem_Type_name, CatalogChangeItem_Type_value)
	proto.RegisterEnum("inodedb.proto.ShardTask_Type", ShardTask_Type_name, ShardTask_Type_value)
	proto.RegisterType((*Node)(nil), "inodedb.proto.Node")
	proto.RegisterType((*Disk)(nil), "inodedb.proto.Disk")
	proto.RegisterType((*DiskReport)(nil), "inodedb.proto.DiskReport")
	proto.RegisterType((*SpaceMeta)(nil), "inodedb.proto.SpaceMeta")
	proto.RegisterType((*Shard)(nil), "inodedb.proto.Shard")
	proto.RegisterType((*ShardNode)(nil), "inodedb.proto.ShardNode")
	proto.RegisterType((*Item)(nil), "inodedb.proto.Item")
	proto.RegisterType((*Field)(nil), "inodedb.proto.Field")
	proto.RegisterType((*FieldMeta)(nil), "inodedb.proto.FieldMeta")
	proto.RegisterType((*Embedding)(nil), "inodedb.proto.Embedding")
	proto.RegisterType((*Link)(nil), "inodedb.proto.Link")
	proto.RegisterType((*GetLink)(nil), "inodedb.proto.GetLink")
	proto.RegisterType((*Unlink)(nil), "inodedb.proto.Unlink")
	proto.RegisterType((*ShardReport)(nil), "inodedb.proto.ShardReport")
	proto.RegisterType((*CatalogChangeItem)(nil), "inodedb.proto.CatalogChangeItem")
	proto.RegisterType((*CatalogChangeSpaceAdd)(nil), "inodedb.proto.CatalogChangeSpaceAdd")
	proto.RegisterType((*CatalogChangeSpaceDelete)(nil), "inodedb.proto.CatalogChangeSpaceDelete")
	proto.RegisterType((*CatalogChangeShardAdd)(nil), "inodedb.proto.CatalogChangeShardAdd")
	proto.RegisterType((*ShardTask)(nil), "inodedb.proto.ShardTask")
}

func init() { proto.RegisterFile("inodedb.proto", fileDescriptor_7e11cd2a3cf7b325) }

var fileDescriptor_7e11cd2a3cf7b325 = []byte{
	// 1588 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0xcf, 0x6f, 0x1b, 0x4f,
	0x15, 0xcf, 0xae, 0x77, 0xed, 0xf5, 0x73, 0x92, 0xef, 0x7e, 0x87, 0x34, 0x75, 0x8a, 0x5a, 0x47,
	0x0b, 0x54, 0x21, 0xa2, 0x0e, 0x69, 0xda, 0x03, 0x14, 0xb5, 0x72, 0x1c, 0x8a, 0x8c, 0xda, 0x14,
	0xd6, 0x0d, 0x07, 0x2e, 0xd6, 0xc6, 0x33, 0x71, 0x56, 0x5e, 0xef, 0x2c, 0xb3, 0xe3, 0xd0, 0x54,
	0x1c, 0xe0, 0x82, 0xc4, 0x99, 0xbf, 0x84, 0x13, 0x57, 0xb8, 0xf5, 0xc8, 0x5f, 0x60, 0x50, 0xc4,
	0xdf, 0x80, 0x44, 0x4f, 0xe8, 0xcd, 0xcc, 0xda, 0x4e, 0xea, 0x54, 0x35, 0xa7, 0xef, 0x69, 0xdf,
	0xaf, 0x99, 0xf7, 0xe6, 0x33, 0xef, 0xc7, 0x2c, 0xac, 0xc5, 0x29, 0xa7, 0x8c, 0x9e, 0x36, 0x33,
	0xc1, 0x25, 0x27, 0xd7, 0xd9, 0x7b, 0x1b, 0x03, 0x3e, 0xe0, 0x8a, 0xdc, 0x43, 0xca, 0x48, 0xb7,
	0x06, 0x9c, 0x0f, 0x12, 0xb6, 0xa7, 0xb8, 0xd3, 0xf1, 0xd9, 0x5e, 0x94, 0x5e, 0x6a, 0x55, 0xf0,
	0x77, 0x1b, 0x9c, 0x63, 0x4e, 0x19, 0xd9, 0x06, 0x3b, 0xa6, 0x75, 0x6b, 0xdb, 0xda, 0x59, 0x3b,
	0xf4, 0xaf, 0x26, 0x0d, 0xbb, 0x73, 0xf4, 0x71, 0xd2, 0x28, 0xa3, 0xae, 0x73, 0x14, 0xda, 0x31,
	0x25, 0xdf, 0x87, 0x72, 0xce, 0x64, 0x2f, 0xa6, 0x75, 0x5b, 0x59, 0x91, 0xab, 0x49, 0xc3, 0xed,
	0x32, 0xa9, 0x0c, 0x35, 0x11, 0xba, 0x39, 0x93, 0x1d, 0x4a, 0x9a, 0xe0, 0xe6, 0x32, 0x92, 0xac,
	0x5e, 0xda, 0xb6, 0x76, 0xd6, 0x1f, 0xd7, 0x9b, 0xd7, 0xa2, 0x6c, 0xe2, 0xa6, 0x5d, 0xd4, 0x87,
	0xda, 0x8c, 0x10, 0x70, 0x22, 0x4a, 0x45, 0xdd, 0xd9, 0xb6, 0x76, 0xaa, 0xa1, 0xa2, 0xc9, 0xb7,
	0xa1, 0x3a, 0x10, 0x59, 0xbf, 0x97, 0x71, 0x21, 0xeb, 0x65, 0xf4, 0x18, 0x7a, 0x28, 0xf8, 0x05,
	0x17, 0x12, 0x95, 0xe7, 0x52, 0x66, 0x5a, 0x59, 0xd1, 0x4a, 0x14, 0x14, 0x4a, 0x11, 0x9d, 0x49,
	0xad, 0xf4, 0xb4, 0x12, 0x05, 0x4a, 0xb9, 0x0e, 0x76, 0xf4, 0xbe, 0x5e, 0x55, 0x8e, 0xec, 0xe8,
	0x3d, 0xba, 0x16, 0x51, 0x7f, 0x58, 0x07, 0xed, 0x1a, 0x69, 0xf2, 0x08, 0x5c, 0xc1, 0x13, 0x96,
	0xd7, 0x6b, 0xdb, 0xa5, 0x9d, 0xf5, 0xc7, 0x77, 0x17, 0x84, 0x1f, 0xf2, 0x84, 0x85, 0xda, 0x2a,
	0xf8, 0x8f, 0x0d, 0xce, 0x51, 0x9c, 0xe3, 0xba, 0x0a, 0x8d, 0xf3, 0x61, 0x6f, 0x0a, 0xe4, 0xc6,
	0xd5, 0xa4, 0x51, 0x46, 0x95, 0x06, 0x53, 0x53, 0x61, 0x19, 0x8d, 0x3a, 0x14, 0xcd, 0x71, 0xdf,
	0x19, 0xa2, 0xca, 0x5c, 0x23, 0x3e, 0x87, 0x7d, 0x19, 0x8d, 0x3a, 0x14, 0x23, 0xcd, 0x22, 0x79,
	0x5e, 0x80, 0x84, 0x34, 0xd9, 0x87, 0x32, 0x22, 0x38, 0xce, 0xeb, 0xae, 0x42, 0x7a, 0xeb, 0x46,
	0xa8, 0xe8, 0xb1, 0xab, 0x0c, 0x42, 0x63, 0x48, 0xee, 0x81, 0x27, 0x58, 0x44, 0x79, 0x9a, 0x5c,
	0x2a, 0x58, 0xbd, 0x70, 0xca, 0x23, 0x72, 0x7d, 0xc1, 0x22, 0xc9, 0x7a, 0x91, 0x86, 0xd5, 0x09,
	0x3d, 0x2d, 0x68, 0x49, 0xd2, 0x80, 0x5a, 0x12, 0xe5, 0xb2, 0x37, 0xce, 0x28, 0x5e, 0xad, 0xa7,
	0xd4, 0x80, 0xa2, 0x13, 0x25, 0x21, 0x3f, 0x86, 0x1a, 0x15, 0x3c, 0xeb, 0x99, 0x88, 0xaa, 0x8b,
	0x23, 0x12, 0x3c, 0x33, 0x11, 0x01, 0x9d, 0xd2, 0xe4, 0x00, 0x9c, 0x38, 0x3d, 0xe3, 0xea, 0x1a,
	0x6a, 0x0b, 0x8f, 0x11, 0x32, 0xbc, 0xcf, 0x43, 0xe7, 0xc3, 0xa4, 0xb1, 0x12, 0x2a, 0xe3, 0xe0,
	0x0f, 0x16, 0xc0, 0x4c, 0xb5, 0x2c, 0xfc, 0x04, 0x9c, 0x71, 0xce, 0x34, 0xf6, 0x4e, 0xa8, 0x68,
	0xb2, 0x01, 0xae, 0xe4, 0x32, 0x4a, 0x54, 0xe2, 0x3a, 0xa1, 0x66, 0x10, 0xb2, 0xfc, 0x3c, 0x12,
	0xb4, 0x9d, 0x4a, 0x85, 0xbe, 0x13, 0x4e, 0xf9, 0xe0, 0x9f, 0x16, 0x54, 0xbb, 0x59, 0xd4, 0x67,
	0xaf, 0x99, 0x8c, 0xc8, 0x16, 0x94, 0x72, 0xe3, 0xde, 0x39, 0xac, 0x7c, 0x9c, 0x34, 0x4a, 0xdd,
	0x98, 0x86, 0x28, 0x43, 0x77, 0x69, 0x34, 0x62, 0xca, 0x5d, 0x35, 0x54, 0x34, 0xf9, 0x01, 0x38,
	0xf2, 0x32, 0xbb, 0xad, 0x4c, 0xd4, 0xb6, 0x6f, 0x2f, 0x33, 0x16, 0x2a, 0x2b, 0xd2, 0x82, 0xd5,
	0xb3, 0xf8, 0x1d, 0xa3, 0xbd, 0xb3, 0x98, 0x25, 0x34, 0xaf, 0x3b, 0xdb, 0xa5, 0x9d, 0xda, 0x27,
	0xab, 0x5e, 0xa2, 0x12, 0x83, 0x31, 0x50, 0xd5, 0xd4, 0x1a, 0x25, 0xcd, 0xc9, 0x63, 0x28, 0xab,
	0xc8, 0x31, 0x5f, 0x70, 0xf1, 0xc6, 0x4d, 0x97, 0xa8, 0x34, 0x0b, 0x8d, 0x65, 0xf0, 0x17, 0x1b,
	0x5c, 0x25, 0x27, 0xfb, 0x06, 0x87, 0x19, 0xc2, 0x9b, 0x57, 0x93, 0x46, 0x45, 0x29, 0x15, 0xc4,
	0x05, 0x19, 0x56, 0x94, 0x5d, 0x47, 0x01, 0xca, 0x32, 0xde, 0x3f, 0x37, 0x28, 0x6b, 0x06, 0xf3,
	0x2c, 0x4e, 0x79, 0x2f, 0x89, 0x47, 0xb1, 0x34, 0x50, 0x7b, 0x71, 0xca, 0x5f, 0x21, 0x4f, 0xb6,
	0x00, 0xe9, 0x9e, 0xba, 0x1b, 0x8d, 0x76, 0x25, 0x4e, 0xf9, 0x09, 0x5e, 0xcf, 0x01, 0x54, 0x13,
	0x16, 0x51, 0x26, 0x30, 0x02, 0x77, 0x1a, 0x81, 0xf7, 0x4a, 0x09, 0xaf, 0xdd, 0xb2, 0xa7, 0x0d,
	0x3b, 0x94, 0x3c, 0x01, 0x17, 0xcf, 0x98, 0xd7, 0xcb, 0x0b, 0xf1, 0x52, 0x21, 0x63, 0xa9, 0x99,
	0x63, 0x6b, 0x63, 0x72, 0x1f, 0x00, 0xa3, 0xe8, 0x8f, 0x45, 0xce, 0x85, 0xa9, 0x05, 0x0c, 0xba,
	0xad, 0x04, 0xa8, 0x4e, 0xe2, 0x74, 0xd8, 0xeb, 0xf3, 0x71, 0x2a, 0x4d, 0x2d, 0x54, 0x51, 0xd2,
	0x46, 0x41, 0xf0, 0x37, 0xcc, 0x8a, 0x62, 0xe3, 0x65, 0x13, 0xb3, 0x0e, 0x95, 0x84, 0x45, 0x22,
	0x65, 0x42, 0xa1, 0xe6, 0x85, 0x05, 0x4b, 0x9e, 0x4d, 0xcb, 0x5d, 0x67, 0xcc, 0x77, 0x6e, 0x3b,
	0x4b, 0x33, 0x8c, 0xce, 0xe4, 0xf5, 0xc2, 0x0f, 0x1e, 0x01, 0xcc, 0xa4, 0xe4, 0x2b, 0xa8, 0x21,
	0x77, 0x92, 0x0e, 0x53, 0xfe, 0xdb, 0xd4, 0x5f, 0x21, 0xeb, 0x5a, 0x7d, 0xcc, 0xc5, 0x28, 0x4a,
	0x7c, 0x2b, 0x38, 0x05, 0xa7, 0x23, 0xd9, 0x88, 0xf8, 0x50, 0x8a, 0x53, 0xae, 0x53, 0x3a, 0x44,
	0x12, 0xef, 0x14, 0x4f, 0x9a, 0x17, 0x77, 0xaa, 0x18, 0x4c, 0x2d, 0x93, 0x97, 0xa5, 0x85, 0xa9,
	0xa5, 0x32, 0xb0, 0x48, 0x2d, 0x6d, 0x19, 0xec, 0x83, 0xab, 0xc4, 0xd3, 0xe2, 0xb0, 0xe6, 0x8a,
	0x63, 0x03, 0xdc, 0x8b, 0x28, 0x19, 0xeb, 0x8a, 0x59, 0x0d, 0x35, 0x13, 0xfc, 0xd9, 0x86, 0xea,
	0x34, 0xc5, 0x17, 0xae, 0xdb, 0x37, 0x45, 0x65, 0x2b, 0x88, 0xee, 0xdf, 0x56, 0x1e, 0xcd, 0xb9,
	0xca, 0x7a, 0x0e, 0x95, 0x38, 0xa5, 0xec, 0x1d, 0xa3, 0x06, 0xd8, 0xef, 0xde, 0xba, 0xaa, 0x83,
	0x76, 0x6f, 0x32, 0x19, 0xf3, 0x34, 0x2c, 0x16, 0x05, 0x2f, 0xc0, 0xc1, 0xdd, 0x88, 0x07, 0xce,
	0x21, 0xe7, 0x89, 0xbf, 0x42, 0x2a, 0x50, 0xea, 0xa4, 0xd2, 0xb7, 0x48, 0x15, 0xdc, 0x97, 0x09,
	0x8f, 0xa4, 0x6f, 0x13, 0x80, 0x72, 0x57, 0x8a, 0x38, 0x1d, 0xf8, 0x25, 0xb2, 0x06, 0xd5, 0x9f,
	0x8e, 0x4e, 0x19, 0xa5, 0xc8, 0x3a, 0xc1, 0x73, 0xa8, 0xcd, 0x6d, 0x8c, 0xfb, 0x1c, 0x8f, 0x13,
	0xdc, 0xa7, 0x06, 0x95, 0x8e, 0x76, 0xe2, 0x5b, 0x64, 0x15, 0xbc, 0x97, 0xe3, 0x24, 0x91, 0xec,
	0x9d, 0xd9, 0xee, 0x24, 0x8d, 0x7f, 0x33, 0x66, 0x7e, 0x29, 0x78, 0x31, 0xb7, 0x1d, 0xb6, 0x2b,
	0x96, 0xb0, 0x11, 0x4b, 0x65, 0x5e, 0xb7, 0xb6, 0x4b, 0x3b, 0x76, 0x38, 0xe5, 0xc9, 0x26, 0x94,
	0x73, 0x3e, 0x16, 0xfd, 0xa2, 0x0f, 0x19, 0x2e, 0xf8, 0x1d, 0x38, 0xaf, 0xe2, 0x74, 0x88, 0xfa,
	0x2c, 0x12, 0x2c, 0x95, 0xe6, 0xc2, 0x0d, 0xb7, 0xb0, 0x7b, 0x6d, 0x80, 0xdb, 0x3f, 0x8f, 0x13,
	0x5a, 0x34, 0x4b, 0xc5, 0xcc, 0xe5, 0x81, 0xf3, 0xc5, 0x79, 0xf0, 0x14, 0x2a, 0x3f, 0x63, 0x72,
	0xd9, 0x00, 0x82, 0x27, 0x88, 0x40, 0xb2, 0xec, 0xaa, 0x3f, 0x59, 0x50, 0x53, 0x85, 0x62, 0xc6,
	0xc6, 0x67, 0x7a, 0xf6, 0x5c, 0xe1, 0xda, 0x5f, 0x50, 0xb8, 0x3f, 0x04, 0x57, 0xf5, 0x3d, 0x05,
	0xc8, 0xe7, 0x9b, 0xab, 0x36, 0x0c, 0xfe, 0x6d, 0xc1, 0xd7, 0xed, 0x48, 0x46, 0x09, 0x1f, 0xb4,
	0xcf, 0xa3, 0x74, 0xc0, 0x54, 0xc9, 0x3d, 0x85, 0x35, 0xc1, 0xc7, 0x92, 0xf5, 0x2e, 0x98, 0xc8,
	0x63, 0x9e, 0x9a, 0xd8, 0xfc, 0x8f, 0x93, 0xc6, 0x6a, 0x88, 0x8a, 0x5f, 0x69, 0x79, 0xb8, 0x2a,
	0xe6, 0x38, 0xf2, 0xa3, 0x6b, 0x89, 0xff, 0xbd, 0x1b, 0xde, 0x3f, 0x71, 0x33, 0x5f, 0x00, 0x3b,
	0xe0, 0xc4, 0x92, 0x8d, 0xa6, 0x81, 0xeb, 0x07, 0x63, 0xb3, 0x78, 0x30, 0x36, 0x5b, 0xe9, 0x65,
	0xa8, 0x2c, 0x82, 0x03, 0x93, 0xea, 0xab, 0xe0, 0xb5, 0x28, 0x55, 0x23, 0xca, 0x5f, 0xc1, 0x6e,
	0x72, 0xc4, 0x12, 0x26, 0x99, 0x16, 0x58, 0x85, 0x1a, 0x0f, 0xe9, 0xdb, 0xc1, 0x5f, 0x2d, 0xb8,
	0x73, 0xcd, 0xbf, 0x32, 0x6b, 0x51, 0xfa, 0x4d, 0x1f, 0x98, 0x41, 0x07, 0xea, 0x9f, 0x06, 0xae,
	0x8f, 0xba, 0x64, 0xec, 0xc1, 0x1f, 0xed, 0x9b, 0x20, 0x20, 0x3a, 0xff, 0x07, 0x08, 0xf3, 0x63,
	0xb8, 0xb4, 0xe4, 0x18, 0x76, 0x6e, 0x1d, 0xc3, 0xee, 0x8d, 0x31, 0x1c, 0x40, 0x59, 0x8f, 0x50,
	0xfd, 0xf8, 0x3e, 0x84, 0xf9, 0x84, 0xd7, 0x9a, 0xd9, 0x68, 0xad, 0x2c, 0x31, 0x5a, 0x83, 0xff,
	0x16, 0xc3, 0xf1, 0x6d, 0x94, 0x0f, 0xa7, 0xed, 0xda, 0x5a, 0xd8, 0xae, 0xa7, 0x76, 0xf3, 0xd9,
	0xba, 0x64, 0x59, 0x1a, 0x78, 0x4b, 0x0b, 0xe0, 0x9d, 0x87, 0xd2, 0x59, 0x12, 0x4a, 0x77, 0x0e,
	0xca, 0xe0, 0xa1, 0x29, 0x8b, 0x75, 0x80, 0x36, 0x4e, 0x6b, 0x9d, 0xf9, 0x6a, 0xaa, 0xb6, 0xcf,
	0x59, 0x7f, 0x98, 0xf1, 0x18, 0xc7, 0xc1, 0xee, 0x43, 0xf0, 0xdb, 0xc9, 0x38, 0x97, 0x4c, 0xbc,
	0xc9, 0x98, 0x88, 0x8a, 0x6e, 0xff, 0x73, 0x1e, 0xe3, 0x0c, 0xf6, 0xc0, 0xf9, 0xe5, 0x38, 0x96,
	0xbe, 0xbd, 0xbb, 0x69, 0x5e, 0x95, 0x6a, 0xd3, 0x2a, 0xb8, 0x1d, 0x44, 0xc5, 0x5f, 0xd9, 0x7d,
	0x01, 0x5e, 0xf1, 0xfb, 0xa1, 0xe6, 0x49, 0x9c, 0x0e, 0x12, 0x53, 0x80, 0xca, 0x65, 0x97, 0x89,
	0x0b, 0x26, 0x7c, 0x0b, 0x95, 0xaf, 0x23, 0xf4, 0xa3, 0x27, 0x85, 0x6a, 0x1b, 0xc2, 0x2f, 0xed,
	0xfe, 0x04, 0xaa, 0xd3, 0xdf, 0x2f, 0x9c, 0x2e, 0xb3, 0x07, 0x40, 0x15, 0xdc, 0x56, 0x12, 0x5f,
	0x60, 0xf5, 0xd6, 0xa0, 0xd2, 0x1d, 0xe7, 0x19, 0xeb, 0x9b, 0x39, 0x83, 0x41, 0x31, 0xea, 0x97,
	0x76, 0x7f, 0x6f, 0x5e, 0xdc, 0xe6, 0x11, 0x71, 0x07, 0xbe, 0x9e, 0x71, 0xb3, 0x9d, 0x36, 0xc0,
	0x9f, 0x89, 0x8b, 0x07, 0xc5, 0x75, 0xe9, 0xa1, 0xe0, 0x43, 0x96, 0xfa, 0x36, 0xb9, 0x0b, 0xdf,
	0x9a, 0xfb, 0x49, 0x61, 0x59, 0x14, 0x9b, 0x09, 0xb9, 0x09, 0xe4, 0xa6, 0x82, 0x51, 0xdf, 0xd9,
	0x3d, 0x00, 0x98, 0xfd, 0x43, 0x60, 0x70, 0xc7, 0x1c, 0x79, 0x7f, 0x05, 0x7b, 0x0e, 0x52, 0x19,
	0xae, 0x57, 0x67, 0x50, 0x1c, 0xa3, 0xbe, 0xbd, 0xdb, 0x82, 0xaf, 0x14, 0x3c, 0xfa, 0x4f, 0x45,
	0x81, 0xba, 0x06, 0xd5, 0x16, 0xa5, 0xaf, 0xd9, 0xe8, 0x94, 0x09, 0x7f, 0x85, 0xf8, 0xb0, 0x1a,
	0xb2, 0x11, 0xbf, 0x60, 0x46, 0x62, 0xa1, 0x41, 0x97, 0x15, 0xef, 0x21, 0xfb, 0x70, 0xf3, 0xc3,
	0xd5, 0x03, 0xeb, 0x1f, 0x57, 0x0f, 0xac, 0x7f, 0x5d, 0x3d, 0xb0, 0x7e, 0xed, 0x35, 0xf7, 0x9e,
	0xe9, 0xee, 0x58, 0x56, 0x9f, 0x83, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x91, 0xe5, 0x1b, 0xf6,
	0x99, 0x0f, 0x00, 0x00,
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Roles) > 0 {
		dAtA2 := make([]byte, len(m.Roles)*10)
		var j1 int
		for _, num := range m.Roles {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintInodedb(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Rack) > 0 {
		i -= len(m.Rack)
		copy(dAtA[i:], m.Rack)
		i = encodeVarintInodedb(dAtA, i, uint64(len(m.Rack)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Az) > 0 {
		i -= len(m.Az)
		copy(dAtA[i:], m.Az)
		i = encodeVarintInodedb(dAtA, i, uint64(len(m.Az)))
		i--
		dAtA[i] = 0x4a
	}
	if m.RaftPort != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.RaftPort))
		i--
		dAtA[i] = 0x40
	}
	if m.HttpPort != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.HttpPort))
		i--
		dAtA[i] = 0x38
	}
	if m.GrpcPort != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.GrpcPort))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintInodedb(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x22
	}
	if m.State != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if m.SetID != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.SetID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Disk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Disk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Disk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintInodedb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if m.DropStatus != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.DropStatus))
		i--
		dAtA[i] = 0x48
	}
	if m.LastUpdate != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.LastUpdate))
		i--
		dAtA[i] = 0x40
	}
	if m.CreateAt != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x38
	}
	if m.Readonly {
		i--
		if m.Readonly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Status != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintInodedb(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x22
	}
	if m.NodeID != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x10
	}
	if m.DiskID != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DiskReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiskReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ShardCnt != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.ShardCnt))
		i--
		dAtA[i] = 0x20
	}
	if m.Total != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x18
	}
	if m.Used != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Used))
		i--
		dAtA[i] = 0x10
	}
	if m.DiskID != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpaceMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpaceMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpaceMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Shards) > 0 {
		for iNdEx := len(m.Shards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Shards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInodedb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.FixedFields) > 0 {
		for iNdEx := len(m.FixedFields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FixedFields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInodedb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Type != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintInodedb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Sid != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Shard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Shard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Shard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LinkCount != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.LinkCount))
		i--
		dAtA[i] = 0x40
	}
	if m.InoCursor != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.InoCursor))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInodedb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.LeaderID != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.LeaderID))
		i--
		dAtA[i] = 0x28
	}
	if m.InoUsed != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.InoUsed))
		i--
		dAtA[i] = 0x20
	}
	if m.InoLimit != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.InoLimit))
		i--
		dAtA[i] = 0x18
	}
	if m.Epoch != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	if m.ShardID != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShardNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.Learner {
		i--
		if m.Learner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.DiskID != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInodedb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Links != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Links))
		i--
		dAtA[i] = 0x10
	}
	if m.Ino != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Ino))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Field) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Field) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Field) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintInodedb(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintInodedb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FieldMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Indexed != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Indexed))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintInodedb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Embedding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Embedding) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Embedding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintInodedb(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Elements) > 0 {
		for iNdEx := len(m.Elements) - 1; iNdEx >= 0; iNdEx-- {
			f4 := math.Float32bits(float32(m.Elements[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f4))
		}
		i = encodeVarintInodedb(dAtA, i, uint64(len(m.Elements)*4))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Link) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Link) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Link) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInodedb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Child != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Child))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintInodedb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Parent != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Parent))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetLink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLink) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLink) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintInodedb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Parent != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Parent))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Unlink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Unlink) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Unlink) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintInodedb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Parent != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Parent))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShardReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Shard.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintInodedb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.DiskID != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x10
	}
	if m.Sid != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CatalogChangeItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CatalogChangeItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CatalogChangeItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInodedb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.RouteVersion != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.RouteVersion))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CatalogChangeSpaceAdd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CatalogChangeSpaceAdd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CatalogChangeSpaceAdd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FixedFields) > 0 {
		for iNdEx := len(m.FixedFields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FixedFields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInodedb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Type != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintInodedb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Sid != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CatalogChangeSpaceDelete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CatalogChangeSpaceDelete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CatalogChangeSpaceDelete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintInodedb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Sid != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CatalogChangeShardAdd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CatalogChangeShardAdd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CatalogChangeShardAdd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInodedb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Leader != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Leader))
		i--
		dAtA[i] = 0x30
	}
	if m.InoLimit != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.InoLimit))
		i--
		dAtA[i] = 0x28
	}
	if m.Epoch != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x20
	}
	if m.ShardID != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintInodedb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Sid != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShardTask) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardTask) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardTask) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Epoch != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x28
	}
	if m.ShardID != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x20
	}
	if m.Sid != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x18
	}
	if m.DiskID != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.DiskID))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintInodedb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintInodedb(dAtA []byte, offset int, v uint64) int {
	offset -= sovInodedb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovInodedb(uint64(m.ID))
	}
	if m.SetID != 0 {
		n += 1 + sovInodedb(uint64(m.SetID))
	}
	if m.State != 0 {
		n += 1 + sovInodedb(uint64(m.State))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovInodedb(uint64(l))
	}
	if m.GrpcPort != 0 {
		n += 1 + sovInodedb(uint64(m.GrpcPort))
	}
	if m.HttpPort != 0 {
		n += 1 + sovInodedb(uint64(m.HttpPort))
	}
	if m.RaftPort != 0 {
		n += 1 + sovInodedb(uint64(m.RaftPort))
	}
	l = len(m.Az)
	if l > 0 {
		n += 1 + l + sovInodedb(uint64(l))
	}
	l = len(m.Rack)
	if l > 0 {
		n += 1 + l + sovInodedb(uint64(l))
	}
	if len(m.Roles) > 0 {
		l = 0
		for _, e := range m.Roles {
			l += sovInodedb(uint64(e))
		}
		n += 1 + sovInodedb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Disk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiskID != 0 {
		n += 1 + sovInodedb(uint64(m.DiskID))
	}
	if m.NodeID != 0 {
		n += 1 + sovInodedb(uint64(m.NodeID))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovInodedb(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovInodedb(uint64(m.Status))
	}
	if m.Readonly {
		n += 2
	}
	if m.CreateAt != 0 {
		n += 1 + sovInodedb(uint64(m.CreateAt))
	}
	if m.LastUpdate != 0 {
		n += 1 + sovInodedb(uint64(m.LastUpdate))
	}
	if m.DropStatus != 0 {
		n += 1 + sovInodedb(uint64(m.DropStatus))
	}
	l = m.Info.Size()
	n += 1 + l + sovInodedb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiskReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiskID != 0 {
		n += 1 + sovInodedb(uint64(m.DiskID))
	}
	if m.Used != 0 {
		n += 1 + sovInodedb(uint64(m.Used))
	}
	if m.Total != 0 {
		n += 1 + sovInodedb(uint64(m.Total))
	}
	if m.ShardCnt != 0 {
		n += 1 + sovInodedb(uint64(m.ShardCnt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpaceMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sid != 0 {
		n += 1 + sovInodedb(uint64(m.Sid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInodedb(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovInodedb(uint64(m.Type))
	}
	if len(m.FixedFields) > 0 {
		for _, e := range m.FixedFields {
			l = e.Size()
			n += 1 + l + sovInodedb(uint64(l))
		}
	}
	if len(m.Shards) > 0 {
		for _, e := range m.Shards {
			l = e.Size()
			n += 1 + l + sovInodedb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Shard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardID != 0 {
		n += 1 + sovInodedb(uint64(m.ShardID))
	}
	if m.Epoch != 0 {
		n += 1 + sovInodedb(uint64(m.Epoch))
	}
	if m.InoLimit != 0 {
		n += 1 + sovInodedb(uint64(m.InoLimit))
	}
	if m.InoUsed != 0 {
		n += 1 + sovInodedb(uint64(m.InoUsed))
	}
	if m.LeaderID != 0 {
		n += 1 + sovInodedb(uint64(m.LeaderID))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovInodedb(uint64(l))
		}
	}
	if m.InoCursor != 0 {
		n += 1 + sovInodedb(uint64(m.InoCursor))
	}
	if m.LinkCount != 0 {
		n += 1 + sovInodedb(uint64(m.LinkCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiskID != 0 {
		n += 1 + sovInodedb(uint64(m.DiskID))
	}
	if m.Learner {
		n += 2
	}
	if m.Status != 0 {
		n += 1 + sovInodedb(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ino != 0 {
		n += 1 + sovInodedb(uint64(m.Ino))
	}
	if m.Links != 0 {
		n += 1 + sovInodedb(uint64(m.Links))
	}
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovInodedb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Field) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInodedb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovInodedb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FieldMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInodedb(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovInodedb(uint64(m.Type))
	}
	if m.Indexed != 0 {
		n += 1 + sovInodedb(uint64(m.Indexed))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Embedding) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Elements) > 0 {
		n += 1 + sovInodedb(uint64(len(m.Elements)*4)) + len(m.Elements)*4
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovInodedb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Link) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Parent != 0 {
		n += 1 + sovInodedb(uint64(m.Parent))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInodedb(uint64(l))
	}
	if m.Child != 0 {
		n += 1 + sovInodedb(uint64(m.Child))
	}
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovInodedb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetLink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Parent != 0 {
		n += 1 + sovInodedb(uint64(m.Parent))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInodedb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Unlink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Parent != 0 {
		n += 1 + sovInodedb(uint64(m.Parent))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInodedb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sid != 0 {
		n += 1 + sovInodedb(uint64(m.Sid))
	}
	if m.DiskID != 0 {
		n += 1 + sovInodedb(uint64(m.DiskID))
	}
	l = m.Shard.Size()
	n += 1 + l + sovInodedb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CatalogChangeItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RouteVersion != 0 {
		n += 1 + sovInodedb(uint64(m.RouteVersion))
	}
	if m.Type != 0 {
		n += 1 + sovInodedb(uint64(m.Type))
	}
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovInodedb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CatalogChangeSpaceAdd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sid != 0 {
		n += 1 + sovInodedb(uint64(m.Sid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInodedb(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovInodedb(uint64(m.Type))
	}
	if len(m.FixedFields) > 0 {
		for _, e := range m.FixedFields {
			l = e.Size()
			n += 1 + l + sovInodedb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CatalogChangeSpaceDelete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sid != 0 {
		n += 1 + sovInodedb(uint64(m.Sid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInodedb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CatalogChangeShardAdd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sid != 0 {
		n += 1 + sovInodedb(uint64(m.Sid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInodedb(uint64(l))
	}
	if m.ShardID != 0 {
		n += 1 + sovInodedb(uint64(m.ShardID))
	}
	if m.Epoch != 0 {
		n += 1 + sovInodedb(uint64(m.Epoch))
	}
	if m.InoLimit != 0 {
		n += 1 + sovInodedb(uint64(m.InoLimit))
	}
	if m.Leader != 0 {
		n += 1 + sovInodedb(uint64(m.Leader))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovInodedb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardTask) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovInodedb(uint64(m.Type))
	}
	if m.DiskID != 0 {
		n += 1 + sovInodedb(uint64(m.DiskID))
	}
	if m.Sid != 0 {
		n += 1 + sovInodedb(uint64(m.Sid))
	}
	if m.ShardID != 0 {
		n += 1 + sovInodedb(uint64(m.ShardID))
	}
	if m.Epoch != 0 {
		n += 1 + sovInodedb(uint64(m.Epoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovInodedb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozInodedb(x uint64) (n int) {
	return sovInodedb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInodedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetID", wireType)
			}
			m.SetID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetID |= SetID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= NodeState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrpcPort", wireType)
			}
			m.GrpcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GrpcPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpPort", wireType)
			}
			m.HttpPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HttpPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftPort", wireType)
			}
			m.RaftPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Az", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Az = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rack", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rack = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType == 0 {
				var v NodeRole
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInodedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= NodeRole(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Roles = append(m.Roles, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInodedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthInodedb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthInodedb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Roles) == 0 {
					m.Roles = make([]NodeRole, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v NodeRole
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInodedb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= NodeRole(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Roles = append(m.Roles, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInodedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInodedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Disk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInodedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Disk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Disk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= DiskStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Readonly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Readonly = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdate", wireType)
			}
			m.LastUpdate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropStatus", wireType)
			}
			m.DropStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropStatus |= DropStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInodedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInodedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInodedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			m.Used = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Used |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardCnt", wireType)
			}
			m.ShardCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardCnt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInodedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInodedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpaceMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInodedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpaceMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpaceMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= Sid(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= SpaceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FixedFields = append(m.FixedFields, FieldMeta{})
			if err := m.FixedFields[len(m.FixedFields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, Shard{})
			if err := m.Shards[len(m.Shards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInodedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInodedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Shard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInodedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= ShardID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InoLimit", wireType)
			}
			m.InoLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InoLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InoUsed", wireType)
			}
			m.InoUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InoUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderID", wireType)
			}
			m.LeaderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderID |= DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, ShardNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InoCursor", wireType)
			}
			m.InoCursor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InoCursor |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkCount", wireType)
			}
			m.LinkCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInodedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInodedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInodedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Learner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Learner = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ShardNode_RaftStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInodedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInodedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInodedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ino", wireType)
			}
			m.Ino = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ino |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			m.Links = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Links |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, Field{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInodedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInodedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Field) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInodedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Field: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Field: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInodedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInodedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInodedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FieldMeta_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexed", wireType)
			}
			m.Indexed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Indexed |= FieldMeta_IndexOption(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInodedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInodedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Embedding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInodedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Embedding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Embedding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Elements = append(m.Elements, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInodedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthInodedb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthInodedb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Elements) == 0 {
					m.Elements = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Elements = append(m.Elements, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Elements", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInodedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInodedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Link) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInodedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Link: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Link: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			m.Parent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Parent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			m.Child = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Child |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, Field{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInodedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInodedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInodedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLink: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLink: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			m.Parent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Parent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInodedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInodedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Unlink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInodedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Unlink: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Unlink: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			m.Parent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Parent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInodedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInodedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInodedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= Sid(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInodedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInodedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CatalogChangeItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInodedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CatalogChangeItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CatalogChangeItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteVersion", wireType)
			}
			m.RouteVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteVersion |= RouteVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CatalogChangeItem_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &types.Any{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInodedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInodedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CatalogChangeSpaceAdd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInodedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CatalogChangeSpaceAdd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CatalogChangeSpaceAdd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= Sid(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= SpaceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FixedFields = append(m.FixedFields, FieldMeta{})
			if err := m.FixedFields[len(m.FixedFields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInodedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInodedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CatalogChangeSpaceDelete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInodedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CatalogChangeSpaceDelete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CatalogChangeSpaceDelete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= Sid(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInodedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInodedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CatalogChangeShardAdd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInodedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CatalogChangeShardAdd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CatalogChangeShardAdd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= Sid(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= ShardID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InoLimit", wireType)
			}
			m.InoLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InoLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInodedb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInodedb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, ShardNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInodedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInodedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardTask) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInodedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardTask: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardTask: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ShardTask_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskID", wireType)
			}
			m.DiskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskID |= DiskID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= Sid(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= ShardID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInodedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInodedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInodedb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInodedb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInodedb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthInodedb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupInodedb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthInodedb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthInodedb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInodedb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupInodedb = fmt.Errorf("proto: unexpected end of group")
)
